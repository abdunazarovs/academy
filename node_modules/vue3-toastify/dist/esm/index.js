import { reactive as F, toRaw as T, createApp as Ce, nextTick as ae, isVNode as se, mergeProps as h, defineComponent as z, ref as b, computed as m, watchEffect as U, createVNode as l, cloneVNode as Ee, onMounted as ye, onUnmounted as Se, h as D, Fragment as ve } from "vue";
const w = {
  TOP_LEFT: "top-left",
  TOP_RIGHT: "top-right",
  TOP_CENTER: "top-center",
  BOTTOM_LEFT: "bottom-left",
  BOTTOM_RIGHT: "bottom-right",
  BOTTOM_CENTER: "bottom-center"
}, $ = {
  LIGHT: "light",
  DARK: "dark",
  COLORED: "colored",
  AUTO: "auto"
}, g = {
  INFO: "info",
  SUCCESS: "success",
  WARNING: "warning",
  ERROR: "error",
  DEFAULT: "default"
}, Te = {
  BOUNCE: "bounce",
  SLIDE: "slide",
  FLIP: "flip",
  ZOOM: "zoom"
}, re = {
  dangerouslyHTMLString: !1,
  multiple: !0,
  position: w.TOP_RIGHT,
  autoClose: 5e3,
  transition: "bounce",
  hideProgressBar: !1,
  pauseOnHover: !0,
  pauseOnFocusLoss: !0,
  closeOnClick: !0,
  className: "",
  bodyClassName: "",
  style: {},
  progressClassName: "",
  progressStyle: {},
  role: "alert",
  theme: "light"
}, pe = {
  rtl: !1,
  newestOnTop: !1,
  toastClassName: ""
}, ie = {
  ...re,
  ...pe
};
({
  ...re,
  type: g.DEFAULT
});
var r = /* @__PURE__ */ ((e) => (e[e.COLLAPSE_DURATION = 300] = "COLLAPSE_DURATION", e[e.DEBOUNCE_DURATION = 50] = "DEBOUNCE_DURATION", e.CSS_NAMESPACE = "Toastify", e))(r || {}), K = /* @__PURE__ */ ((e) => (e.ENTRANCE_ANIMATION_END = "d", e))(K || {});
const Ae = {
  enter: "Toastify--animate Toastify__bounce-enter",
  exit: "Toastify--animate Toastify__bounce-exit",
  appendPosition: !0
}, Ne = {
  enter: "Toastify--animate Toastify__slide-enter",
  exit: "Toastify--animate Toastify__slide-exit",
  appendPosition: !0
}, Ie = {
  enter: "Toastify--animate Toastify__zoom-enter",
  exit: "Toastify--animate Toastify__zoom-exit"
}, _e = {
  enter: "Toastify--animate Toastify__flip-enter",
  exit: "Toastify--animate Toastify__flip-exit"
};
function le(e) {
  let t = Ae;
  if (!e || typeof e == "string")
    switch (e) {
      case "flip":
        t = _e;
        break;
      case "zoom":
        t = Ie;
        break;
      case "slide":
        t = Ne;
        break;
    }
  else
    t = e;
  return t;
}
function he(e) {
  return e.containerId || String(e.position);
}
const j = "will-unmount";
function Oe(e = w.TOP_RIGHT) {
  return !!document.querySelector(`.${r.CSS_NAMESPACE}__toast-container--${e}`);
}
function Pe(e = w.TOP_RIGHT) {
  return `${r.CSS_NAMESPACE}__toast-container--${e}`;
}
function be(e, t, n = !1) {
  const o = [
    `${r.CSS_NAMESPACE}__toast-container`,
    `${r.CSS_NAMESPACE}__toast-container--${e}`,
    n ? `${r.CSS_NAMESPACE}__toast-container--rtl` : null
  ].filter(Boolean).join(" ");
  return L(t) ? t({
    position: e,
    rtl: n,
    defaultClassName: o
  }) : `${o} ${t || ""}`;
}
function Le(e) {
  var y;
  const { position: t, containerClassName: n, rtl: o = !1, style: a = {} } = e, s = r.CSS_NAMESPACE, d = Pe(t), E = document.querySelector(`.${s}`), u = document.querySelector(`.${d}`), C = !!u && !((y = u.className) != null && y.includes(j)), c = E || document.createElement("div"), v = document.createElement("div");
  v.className = be(
    t,
    n,
    o
  ), v.dataset.testid = `${r.CSS_NAMESPACE}__toast-container--${t}`, v.id = he(e);
  for (const A in a)
    if (Object.prototype.hasOwnProperty.call(a, A)) {
      const Q = a[A];
      v.style[A] = Q;
    }
  return E || (c.className = r.CSS_NAMESPACE, document.body.appendChild(c)), C || c.appendChild(v), v;
}
function Y(e) {
  var o, a, s;
  const t = typeof e == "string" ? e : ((o = e.currentTarget) == null ? void 0 : o.id) || ((a = e.target) == null ? void 0 : a.id), n = document.getElementById(t);
  n && n.removeEventListener("animationend", Y, !1);
  try {
    R[t].unmount(), (s = document.getElementById(t)) == null || s.remove(), delete R[t], delete f[t];
  } catch {
  }
}
const R = F({});
function $e(e, t) {
  const n = document.getElementById(String(t));
  n && (R[n.id] = e);
}
function Z(e, t = !0) {
  const n = String(e);
  if (!R[n])
    return;
  const o = document.getElementById(n);
  o && o.classList.add(j), t ? (qe(e), o && o.addEventListener("animationend", Y, !1)) : Y(n), p.items = p.items.filter((a) => a.containerId !== e);
}
function Be(e) {
  for (const t in R)
    Z(t, e);
  p.items = [];
}
function ue(e, t) {
  const n = document.getElementById(e.toastId);
  if (n) {
    let o = e;
    o = {
      ...o,
      ...le(o.transition)
    };
    const a = o.appendPosition ? `${o.exit}--${o.position}` : o.exit;
    n.className += ` ${a}`, t && t(n);
  }
}
function qe(e) {
  for (const t in f)
    if (t === e)
      for (const n of f[t] || [])
        ue(n);
}
function Me(e) {
  const n = x().find((o) => o.toastId === e);
  return n == null ? void 0 : n.containerId;
}
function ne(e) {
  return document.getElementById(e);
}
function Re(e) {
  const t = ne(e.containerId);
  return t && t.classList.contains(j);
}
function oe(e) {
  var n;
  const t = se(e.content) ? T(e.content.props) : null;
  return t != null ? t : T((n = e.data) != null ? n : {});
}
function Fe(e) {
  return e ? p.items.filter((n) => n.containerId === e).length > 0 : p.items.length > 0;
}
function we() {
  if (p.items.length > 0) {
    const e = p.items.shift();
    X(e == null ? void 0 : e.toastContent, e == null ? void 0 : e.toastProps);
  }
}
const f = F({}), p = F({
  items: []
});
function x() {
  const e = T(f);
  return Object.values(e).reduce((t, n) => [...t, ...n], []);
}
function xe(e) {
  return x().find((n) => n.toastId === e);
}
function X(e, t = {}) {
  if (Re(t)) {
    const n = ne(t.containerId);
    n && n.addEventListener("animationend", J.bind(null, e, t), !1);
  } else
    J(e, t);
}
function J(e, t = {}) {
  const n = ne(t.containerId);
  n && n.removeEventListener("animationend", J.bind(null, e, t), !1);
  const o = f[t.containerId] || [], a = o.length > 0;
  if (!a && !Oe(t.position)) {
    const s = Le(t), d = Ce(ot, t);
    d.mount(s), $e(d, s.id);
  }
  a && (t.position = o[0].position), ae(() => {
    t.updateId ? N.update(t) : N.add(e, t);
  });
}
const N = {
  /**
   * add a toast
   * @param _ ..
   * @param opts toast props
   */
  add(e, t) {
    const { containerId: n = "" } = t;
    n && (f[n] = f[n] || [], f[n].find((o) => o.toastId === t.toastId) || setTimeout(() => {
      var o, a;
      t.newestOnTop ? (o = f[n]) == null || o.unshift(t) : (a = f[n]) == null || a.push(t), t.onOpen && t.onOpen(oe(t));
    }, t.delay || 0));
  },
  /**
   * remove a toast
   * @param id toastId
   */
  remove(e) {
    if (e) {
      const t = Me(e);
      if (t) {
        const n = f[t];
        let o = n.find((a) => a.toastId === e);
        f[t] = n.filter((a) => a.toastId !== e), !f[t].length && !Fe(t) && Z(t, !1), we(), ae(() => {
          o != null && o.onClose && (o.onClose(oe(o)), o = void 0);
        });
      }
    }
  },
  /**
   * update the toast
   * @param opts toast props
   */
  update(e = {}) {
    const { containerId: t = "" } = e;
    if (t && e.updateId) {
      f[t] = f[t] || [];
      const n = f[t].find((o) => o.toastId === e.toastId);
      n && setTimeout(() => {
        for (const o in e)
          if (Object.prototype.hasOwnProperty.call(e, o)) {
            const a = e[o];
            n[o] = a;
          }
      }, e.delay || 0);
    }
  },
  /**
   * clear all toasts in container.
   * @param containerId container id
   */
  clear(e, t = !0) {
    e ? Z(e, t) : Be(t);
  },
  dismissCallback(e) {
    var o;
    const t = (o = e.currentTarget) == null ? void 0 : o.id, n = document.getElementById(t);
    n && (n.removeEventListener("animationend", N.dismissCallback, !1), setTimeout(() => {
      N.remove(t);
    }));
  },
  dismiss(e) {
    if (e) {
      const t = x();
      for (const n of t)
        if (n.toastId === e) {
          ue(n, (o) => {
            o.addEventListener("animationend", N.dismissCallback, !1);
          });
          break;
        }
    }
  }
}, de = F({});
function ce() {
  return Math.random().toString(36).substring(2, 9);
}
function De(e) {
  return typeof e == "number" && !isNaN(e);
}
function ee(e) {
  return typeof e == "string";
}
function L(e) {
  return typeof e == "function";
}
function G(...e) {
  return h(...e);
}
function k(e) {
  return typeof e == "object" && (!!(e != null && e.render) || !!(e != null && e.setup) || typeof (e == null ? void 0 : e.type) == "object");
}
function Ue(e = {}) {
  de[`${r.CSS_NAMESPACE}-default-options`] = e;
}
function ke() {
  return de[`${r.CSS_NAMESPACE}-default-options`] || ie;
}
function He() {
  return document.documentElement.classList.contains("dark") ? "dark" : "light";
}
var H = /* @__PURE__ */ ((e) => (e[e.Enter = 0] = "Enter", e[e.Exit = 1] = "Exit", e))(H || {});
const fe = {
  containerId: {
    type: [String, Number],
    required: !1,
    default: ""
  },
  dangerouslyHTMLString: {
    type: Boolean,
    required: !1,
    default: !1
  },
  multiple: {
    type: Boolean,
    required: !1,
    default: !0
  },
  limit: {
    type: Number,
    required: !1,
    default: void 0
  },
  position: {
    type: String,
    required: !1,
    default: w.TOP_LEFT
  },
  bodyClassName: {
    type: String,
    required: !1,
    default: ""
  },
  autoClose: {
    type: [Number, Boolean],
    required: !1,
    default: !1
  },
  closeButton: {
    type: [Boolean, Function, Object],
    required: !1,
    default: void 0
  },
  transition: {
    type: [String, Object],
    required: !1,
    default: "bounce"
  },
  hideProgressBar: {
    type: Boolean,
    required: !1,
    default: !1
  },
  pauseOnHover: {
    type: Boolean,
    required: !1,
    default: !0
  },
  pauseOnFocusLoss: {
    type: Boolean,
    required: !1,
    default: !0
  },
  closeOnClick: {
    type: Boolean,
    required: !1,
    default: !0
  },
  progress: {
    type: Number,
    required: !1,
    default: void 0
  },
  progressClassName: {
    type: String,
    required: !1,
    default: ""
  },
  toastStyle: {
    type: Object,
    required: !1,
    default() {
      return {};
    }
  },
  progressStyle: {
    type: Object,
    required: !1,
    default() {
      return {};
    }
  },
  role: {
    type: String,
    required: !1,
    default: "alert"
  },
  theme: {
    type: String,
    required: !1,
    default: $.AUTO
  },
  content: {
    type: [String, Object, Function],
    required: !1,
    default: ""
  },
  toastId: {
    type: [String, Number],
    required: !1,
    default: ""
  },
  data: {
    type: [Object, String],
    required: !1,
    default() {
      return {};
    }
  },
  type: {
    type: String,
    required: !1,
    default: g.DEFAULT
  },
  icon: {
    type: [Boolean, String, Number, Object, Function],
    required: !1,
    default: void 0
  },
  delay: {
    type: Number,
    required: !1,
    default: void 0
  },
  onOpen: {
    type: Function,
    required: !1,
    default: void 0
  },
  onClose: {
    type: Function,
    required: !1,
    default: void 0
  },
  onClick: {
    type: Function,
    required: !1,
    default: void 0
  },
  isLoading: {
    type: Boolean,
    required: !1,
    default: void 0
  },
  rtl: {
    type: Boolean,
    required: !1,
    default: !1
  },
  toastClassName: {
    type: String,
    required: !1,
    default: ""
  },
  updateId: {
    type: [String, Number],
    required: !1,
    default: ""
  }
}, ze = {
  autoClose: {
    type: [Number, Boolean],
    required: !0
  },
  isRunning: {
    type: Boolean,
    required: !1,
    default: void 0
  },
  type: {
    type: String,
    required: !1,
    default: g.DEFAULT
  },
  theme: {
    type: String,
    required: !1,
    default: $.AUTO
  },
  hide: {
    type: Boolean,
    required: !1,
    default: void 0
  },
  className: {
    type: [String, Function],
    required: !1,
    default: ""
  },
  controlledProgress: {
    type: Boolean,
    required: !1,
    default: void 0
  },
  rtl: {
    type: Boolean,
    required: !1,
    default: void 0
  },
  isIn: {
    type: Boolean,
    required: !1,
    default: void 0
  },
  progress: {
    type: Number,
    required: !1,
    default: void 0
  },
  closeToast: {
    type: Function,
    required: !1,
    default: void 0
  }
}, je = /* @__PURE__ */ z({
  name: "ProgressBar",
  props: ze,
  // @ts-ignore
  setup(e, {
    attrs: t
  }) {
    const n = b(), o = m(() => e.hide ? "true" : "false"), a = m(() => ({
      ...t.style || {},
      animationDuration: `${e.autoClose === !0 ? 5e3 : e.autoClose}ms`,
      animationPlayState: e.isRunning ? "running" : "paused",
      opacity: e.hide ? 0 : 1,
      transform: e.controlledProgress ? `scaleX(${e.progress})` : "none"
    })), s = m(() => [`${r.CSS_NAMESPACE}__progress-bar`, e.controlledProgress ? `${r.CSS_NAMESPACE}__progress-bar--controlled` : `${r.CSS_NAMESPACE}__progress-bar--animated`, `${r.CSS_NAMESPACE}__progress-bar-theme--${e.theme}`, `${r.CSS_NAMESPACE}__progress-bar--${e.type}`, e.rtl ? `${r.CSS_NAMESPACE}__progress-bar--rtl` : null].filter(Boolean).join(" ")), d = m(() => `${s.value} ${(t == null ? void 0 : t.class) || ""}`), E = () => {
      n.value && (n.value.onanimationend = null, n.value.ontransitionend = null);
    }, u = () => {
      e.isIn && e.closeToast && e.autoClose !== !1 && (e.closeToast(), E());
    }, C = m(() => e.controlledProgress ? null : u), c = m(() => e.controlledProgress ? u : null);
    return U(() => {
      n.value && (E(), n.value.onanimationend = C.value, n.value.ontransitionend = c.value);
    }), () => l("div", {
      ref: n,
      role: "progressbar",
      "aria-hidden": o.value,
      "aria-label": "notification timer",
      class: d.value,
      style: a.value
    }, null);
  }
}), Ge = /* @__PURE__ */ z({
  name: "CloseButton",
  inheritAttrs: !1,
  props: {
    theme: {
      type: String,
      required: !1,
      default: $.AUTO
    },
    type: {
      type: String,
      required: !1,
      default: $.LIGHT
    },
    ariaLabel: {
      type: String,
      required: !1,
      default: "close"
    },
    closeToast: {
      type: Function,
      required: !1,
      default: void 0
    }
  },
  setup(e) {
    return () => l("button", {
      class: `${r.CSS_NAMESPACE}__close-button ${r.CSS_NAMESPACE}__close-button--${e.theme}`,
      type: "button",
      onClick: (t) => {
        t.stopPropagation(), e.closeToast && e.closeToast(t);
      },
      "aria-label": e.ariaLabel
    }, [l("svg", {
      "aria-hidden": "true",
      viewBox: "0 0 14 16"
    }, [l("path", {
      "fill-rule": "evenodd",
      d: "M7.71 8.23l3.75 3.75-1.48 1.48-3.75-3.75-3.75 3.75L1 11.98l3.75-3.75L1 4.48 2.48 3l3.75 3.75L9.98 3l1.48 1.48-3.75 3.75z"
    }, null)])]);
  }
}), V = ({
  theme: e,
  type: t,
  path: n,
  ...o
}) => l("svg", h({
  viewBox: "0 0 24 24",
  width: "100%",
  height: "100%",
  fill: e === "colored" ? "currentColor" : `var(--toastify-icon-color-${t})`
}, o), [l("path", {
  d: n
}, null)]);
function Ve(e) {
  return l(V, h(e, {
    path: "M23.32 17.191L15.438 2.184C14.728.833 13.416 0 11.996 0c-1.42 0-2.733.833-3.443 2.184L.533 17.448a4.744 4.744 0 000 4.368C1.243 23.167 2.555 24 3.975 24h16.05C22.22 24 24 22.044 24 19.632c0-.904-.251-1.746-.68-2.44zm-9.622 1.46c0 1.033-.724 1.823-1.698 1.823s-1.698-.79-1.698-1.822v-.043c0-1.028.724-1.822 1.698-1.822s1.698.79 1.698 1.822v.043zm.039-12.285l-.84 8.06c-.057.581-.408.943-.897.943-.49 0-.84-.367-.896-.942l-.84-8.065c-.057-.624.25-1.095.779-1.095h1.91c.528.005.84.476.784 1.1z"
  }), null);
}
function Qe(e) {
  return l(V, h(e, {
    path: "M12 0a12 12 0 1012 12A12.013 12.013 0 0012 0zm.25 5a1.5 1.5 0 11-1.5 1.5 1.5 1.5 0 011.5-1.5zm2.25 13.5h-4a1 1 0 010-2h.75a.25.25 0 00.25-.25v-4.5a.25.25 0 00-.25-.25h-.75a1 1 0 010-2h1a2 2 0 012 2v4.75a.25.25 0 00.25.25h.75a1 1 0 110 2z"
  }), null);
}
function We(e) {
  return l(V, h(e, {
    path: "M12 0a12 12 0 1012 12A12.014 12.014 0 0012 0zm6.927 8.2l-6.845 9.289a1.011 1.011 0 01-1.43.188l-4.888-3.908a1 1 0 111.25-1.562l4.076 3.261 6.227-8.451a1 1 0 111.61 1.183z"
  }), null);
}
function Ke(e) {
  return l(V, h(e, {
    path: "M11.983 0a12.206 12.206 0 00-8.51 3.653A11.8 11.8 0 000 12.207 11.779 11.779 0 0011.8 24h.214A12.111 12.111 0 0024 11.791 11.766 11.766 0 0011.983 0zM10.5 16.542a1.476 1.476 0 011.449-1.53h.027a1.527 1.527 0 011.523 1.47 1.475 1.475 0 01-1.449 1.53h-.027a1.529 1.529 0 01-1.523-1.47zM11 12.5v-6a1 1 0 012 0v6a1 1 0 11-2 0z"
  }), null);
}
function Ye() {
  return l("div", {
    class: `${r.CSS_NAMESPACE}__spinner`
  }, null);
}
const te = {
  info: Qe,
  warning: Ve,
  success: We,
  error: Ke,
  spinner: Ye
}, Ze = (e) => e in te;
function Xe({
  theme: e,
  type: t,
  isLoading: n,
  icon: o
}) {
  let a;
  const s = {
    theme: e,
    type: t
  };
  return n ? a = te.spinner() : o === !1 ? a = void 0 : k(o) ? a = T(o) : L(o) ? a = o(s) : se(o) ? a = Ee(o, s) : ee(o) || De(o) ? a = o : Ze(t) && (a = te[t](s)), a;
}
const Je = () => {
};
function et(e, t, n = r.COLLAPSE_DURATION) {
  const { scrollHeight: o, style: a } = e, s = n;
  requestAnimationFrame(() => {
    a.minHeight = "initial", a.height = o + "px", a.transition = `all ${s}ms`, requestAnimationFrame(() => {
      a.height = "0", a.padding = "0", a.margin = "0", setTimeout(t, s);
    });
  });
}
function tt(e) {
  const t = b(!1), n = b(!1), o = b(!1), a = b(H.Enter), s = F({
    ...e,
    appendPosition: e.appendPosition || !1,
    collapse: typeof e.collapse > "u" ? !0 : e.collapse,
    collapseDuration: e.collapseDuration || r.COLLAPSE_DURATION
  }), d = s.done || Je, E = m(() => s.appendPosition ? `${s.enter}--${s.position}` : s.enter), u = m(() => s.appendPosition ? `${s.exit}--${s.position}` : s.exit), C = m(() => e.pauseOnHover ? {
    onMouseenter: q,
    onMouseleave: B
  } : {});
  function c() {
    const S = E.value.split(" ");
    y().addEventListener(
      K.ENTRANCE_ANIMATION_END,
      B,
      { once: !0 }
    );
    const I = (P) => {
      const M = y();
      P.target === M && (M.dispatchEvent(new Event(K.ENTRANCE_ANIMATION_END)), M.removeEventListener("animationend", I), M.removeEventListener("animationcancel", I), a.value === H.Enter && P.type !== "animationcancel" && M.classList.remove(...S));
    }, _ = () => {
      const P = y();
      P.classList.add(...S), P.addEventListener("animationend", I), P.addEventListener("animationcancel", I);
    };
    e.pauseOnFocusLoss && A(), _();
  }
  function v() {
    if (!y())
      return;
    const S = () => {
      const _ = y();
      _.removeEventListener("animationend", S), s.collapse ? et(_, d, s.collapseDuration) : d();
    }, I = () => {
      const _ = y();
      a.value = H.Exit, _ && (_.className += ` ${u.value}`, _.addEventListener("animationend", S));
    };
    n.value || (o.value ? S() : setTimeout(I));
  }
  function y() {
    return e.toastRef.value;
  }
  function A() {
    document.hasFocus() || q(), window.addEventListener("focus", B), window.addEventListener("blur", q);
  }
  function Q() {
    window.removeEventListener("focus", B), window.removeEventListener("blur", q);
  }
  function B() {
    (!e.loading.value || e.isLoading === void 0) && (t.value = !0);
  }
  function q() {
    t.value = !1;
  }
  function ge(S) {
    S && (S.stopPropagation(), S.preventDefault()), n.value = !1;
  }
  return U(v), U(() => {
    const S = x();
    n.value = S.findIndex((I) => I.toastId === s.toastId) > -1;
  }), U(() => {
    e.isLoading !== void 0 && (e.loading.value ? q() : B());
  }), ye(c), Se(() => {
    e.pauseOnFocusLoss && Q();
  }), {
    isIn: n,
    isRunning: t,
    hideToast: ge,
    eventHandlers: C
  };
}
const nt = /* @__PURE__ */ z({
  name: "ToastItem",
  inheritAttrs: !1,
  props: fe,
  // @ts-ignore
  setup(e) {
    const t = b(), n = m(() => !!e.isLoading), o = m(() => e.progress !== void 0 && e.progress !== null), a = m(() => Xe(e)), s = m(() => [`${r.CSS_NAMESPACE}__toast`, `${r.CSS_NAMESPACE}__toast-theme--${e.theme}`, `${r.CSS_NAMESPACE}__toast--${e.type}`, e.rtl ? `${r.CSS_NAMESPACE}__toast--rtl` : void 0, e.toastClassName || ""].filter(Boolean).join(" ")), {
      isRunning: d,
      isIn: E,
      hideToast: u,
      eventHandlers: C
    } = tt({
      toastRef: t,
      loading: n,
      done: () => {
        N.remove(e.toastId);
      },
      ...le(e.transition),
      ...e
    });
    return () => l("div", h({
      id: e.toastId,
      class: s.value,
      style: e.toastStyle || {},
      ref: t,
      "data-testid": `toast-item-${e.toastId}`,
      onClick: (c) => {
        e.closeOnClick && u(), e.onClick && e.onClick(c);
      }
    }, C.value), [l("div", {
      role: e.role,
      "data-testid": "toast-body",
      class: `${r.CSS_NAMESPACE}__toast-body ${e.bodyClassName || ""}`
    }, [a.value != null && l("div", {
      "data-testid": `toast-icon-${e.type}`,
      class: [`${r.CSS_NAMESPACE}__toast-icon`, e.isLoading ? "" : `${r.CSS_NAMESPACE}--animate-icon ${r.CSS_NAMESPACE}__zoom-enter`].join(" ")
    }, [k(a.value) ? D(T(a.value), {
      theme: e.theme,
      type: e.type
    }) : L(a.value) ? a.value({
      theme: e.theme,
      type: e.type
    }) : a.value]), l("div", {
      "data-testid": "toast-content"
    }, [k(e.content) ? D(T(e.content), {
      toastProps: T(e),
      closeToast: u,
      data: e.data
    }) : L(e.content) ? e.content({
      toastProps: T(e),
      closeToast: u,
      data: e.data
    }) : e.dangerouslyHTMLString ? D("div", {
      innerHTML: e.content
    }) : e.content])]), (e.closeButton === void 0 || e.closeButton === !0) && l(Ge, {
      theme: e.theme,
      closeToast: (c) => {
        c.stopPropagation(), c.preventDefault(), u();
      }
    }, null), k(e.closeButton) ? D(T(e.closeButton), {
      closeToast: u,
      type: e.type,
      theme: e.theme
    }) : L(e.closeButton) ? e.closeButton({
      closeToast: u,
      type: e.type,
      theme: e.theme
    }) : null, l(je, {
      className: e.progressClassName,
      style: e.progressStyle,
      rtl: e.rtl,
      theme: e.theme,
      isIn: E.value,
      type: e.type,
      hide: e.hideProgressBar,
      isRunning: d.value,
      autoClose: e.autoClose,
      controlledProgress: o.value,
      progress: e.progress,
      closeToast: e.isLoading ? void 0 : u
    }, null)]);
  }
}), ot = /* @__PURE__ */ z({
  name: "ToastifyContainer",
  inheritAttrs: !1,
  props: fe,
  // @ts-ignore
  setup(e) {
    const t = m(() => e.containerId), n = m(() => f[t.value] || []), o = m(() => n.value.filter((a) => a.position === e.position));
    return () => l(ve, null, [o.value.map((a) => {
      const {
        toastId: s = ""
      } = a;
      return l(nt, h({
        key: s
      }, a), null);
    })]);
  }
});
let W = !1;
function me() {
  const e = [];
  return x().forEach((n) => {
    const o = document.getElementById(n.containerId);
    o && !o.classList.contains(j) && e.push(n);
  }), e;
}
function at(e) {
  const t = me().length, n = e != null ? e : 0;
  return n > 0 && t + p.items.length >= n;
}
function st(e) {
  at(e.limit) && !e.updateId && p.items.push({
    toastId: e.toastId,
    containerId: e.containerId,
    toastContent: e.content,
    toastProps: e
  });
}
function O(e, t, n = {}) {
  if (W)
    return;
  n = G(ke(), t, n), (!n.toastId || typeof n.toastId != "string" && typeof n.toastId != "number") && (n.toastId = ce()), n = {
    ...n,
    content: e,
    containerId: n.containerId || String(n.position)
  };
  const o = Number(n == null ? void 0 : n.progress);
  return o < 0 && (n.progress = 0), o > 1 && (n.progress = 1), n.theme === "auto" && (n.theme = He()), st(n), n.multiple ? p.items.length || X(e, n) : (W = !0, i.clearAll(void 0, !1), setTimeout(() => {
    X(e, n);
  }, 0), setTimeout(() => {
    W = !1;
  }, 390)), n.toastId;
}
const i = (e, t) => O(e, g.DEFAULT, t);
i.info = (e, t) => O(e, g.DEFAULT, {
  ...t,
  type: g.INFO
});
i.error = (e, t) => O(e, g.DEFAULT, {
  ...t,
  type: g.ERROR
});
i.warning = (e, t) => O(e, g.DEFAULT, {
  ...t,
  type: g.WARNING
});
i.warn = i.warning;
i.success = (e, t) => O(e, g.DEFAULT, {
  ...t,
  type: g.SUCCESS
});
i.loading = (e, t) => O(e, g.DEFAULT, G(t, {
  isLoading: !0,
  autoClose: !1,
  closeOnClick: !1,
  closeButton: !1,
  draggable: !1
}));
i.dark = (e, t) => O(e, g.DEFAULT, G(t, {
  theme: $.DARK
}));
i.remove = (e) => {
  e ? N.dismiss(e) : N.clear();
};
i.clearAll = (e, t) => {
  N.clear(e, t);
};
i.isActive = (e) => {
  let t = !1;
  return t = me().findIndex((o) => o.toastId === e) > -1, t;
};
i.update = (e, t = {}) => {
  setTimeout(() => {
    const n = xe(e);
    if (n) {
      const o = T(n), {
        content: a
      } = o, s = {
        ...o,
        ...t,
        toastId: t.toastId || e,
        updateId: ce()
      }, d = s.render || a;
      delete s.render, O(d, s.type, s);
    }
  }, 0);
};
i.done = (e) => {
  i.update(e, {
    isLoading: !1,
    progress: 1
  });
};
i.promise = rt;
function rt(e, {
  pending: t,
  error: n,
  success: o
}, a) {
  let s;
  t && (s = ee(t) ? i.loading(t, a) : i.loading(t.render, {
    ...a,
    ...t
  }));
  const d = {
    isLoading: void 0,
    autoClose: null,
    closeOnClick: null,
    closeButton: null,
    draggable: null,
    delay: 100
  }, E = (C, c, v) => {
    if (c == null) {
      i.remove(s);
      return;
    }
    const y = {
      type: C,
      ...d,
      ...a,
      data: v
    }, A = ee(c) ? {
      render: c
    } : c;
    return s ? i.update(s, {
      ...y,
      ...A,
      isLoading: !1,
      autoClose: !0
    }) : i(A.render, {
      ...y,
      ...A,
      isLoading: !1,
      autoClose: !0
    }), v;
  }, u = L(e) ? e() : e;
  return u.then((C) => E("success", o, C)).catch((C) => E("error", n, C)), u;
}
i.POSITION = w;
i.THEME = $;
i.TYPE = g;
i.TRANSITIONS = Te;
const it = {
  install(e, t = {}) {
    lt(t);
  }
};
typeof window < "u" && (window.Vue3Toastify = it);
function lt(e = {}) {
  const t = G(ie, e);
  Ue(t);
}
export {
  H as AnimationStep,
  Ae as Bounce,
  _e as Flip,
  Ne as Slide,
  N as ToastActions,
  ot as ToastifyContainer,
  Ie as Zoom,
  ue as addExitAnimateToNode,
  we as appendFromQueue,
  $e as cacheRenderInstance,
  Be as clearContainers,
  R as containerInstances,
  it as default,
  X as doAppend,
  x as getAllToast,
  xe as getToast,
  de as globalOptions,
  p as queue,
  Z as removeContainer,
  i as toast,
  f as toastContainers,
  lt as updateGlobalOptions,
  tt as useCssTransition
};
